# What is k8s (Kubernetes)?
## 도커의 등장

### 컨테이너 특징

- 가상머신과 비교하여 컨테이너 생성이 쉽고 효율적
- 컨테이너 이미지를 이용한 배포와 롤백이 간단
- 언어나 프레임워크에 상관없이 애플리케이션을 동일한 방식으로 관리
- 개발, 테스팅, 운영 환경은 물론 로컬 PC와 클라우드까지 동일한 환경 구축
- 특정 클라우드 벤더에 종속적이지 않음

그래서 모든 걸 컨테이너로 관리하기 시작..! → **컨테이너화(Containerization)**


도커 이미지만 잘 만들어 두면 컨테이너를 띄우고 관리하는 것이 매우 간단해진다.

그렇게 컨테이너를 쓰다가 수십개.. 수백개.. 수천개까지 늘어나게 된다면? 

도커가 좋긴 한데.. 이렇게 많은 컨테이너를 관리하기는 복잡하다.

### 도커의 한계

- 수작업 관리 : 각 서버에 SSH로 접속해 직접 도커 컨테이너를 stop, run하는 작업은 비효율적
- 모니터링 도구 부족 : 어떤 서버가 여유 있는지 확인하기 어려움
- 롤아웃/롤백의 어려움 : 컨테이너를 업데이트 했지만 문제가 발생하면 롤백이 번거로움


## 컨테이너 오케스트레이션

복잡한 컨테이너 환경을 효과적으로 관리하기 위한 도구

### 복잡한 컨테이너 환경 관리의 필요성

기존에는 서로 다른 CPU와 RAM을 가진 서버를 서버 관리자가 하나하나 관리를 해주었다. 

그런데 서버가 많아지면서, 서버를 개별적으로 관리하는 것을 비효율적이다.

이를 해결하기 위해 클러스터 단위로 추상화하여 관리한다.

그리고 서버 하나하나에 접속하기가 어렵기 때문에 **마스터 서버**를 하나 두고 관리자가 마스터 서버에게 명령을 내리면 마스터 서버가 알아서 노드에게 명령들을 보낸다.

- **마스터 서버** : 관리자가 명령을 내리면 마스터 서버가 각 노드에 명령을 전달한다.

## **Kubernetes (K8s)**
 

![image](https://github.com/user-attachments/assets/eb37efa8-4b70-4016-8f64-4831064218d8)
k8s는 지휘자. 도커 컨테이너는 연주자 (사진 출처 : https://jibinary.tistory.com/82)


> **Kubernetes : 컨테이너 오케스트레이션을 위한 오픈소스 플랫폼.**


> **K**ubernete**s (K8s)**
> 
→ 쿠버네티스, 케잇츠, 쿠베, 큐브 라고도 불린다!

## 쿠버네티스의 구성 요소


![image](https://github.com/user-attachments/assets/4257ce90-0d1d-4142-8d79-043b819aae5d)


### 컨트롤 플레인 (Master Node)


![image](https://github.com/user-attachments/assets/7deab256-76fa-457e-a8a1-81c60d33cef6)


1. **API Server**
- 컨트롤 플레인의 프론트엔드 역할
- 조회나 요청은 모두 API Server를 통해 이루어짐
- etcd와 직접 통신하는 유일한 모듈

2. **Controller Manager**
- 다양한 컨트롤러 프로세스를 실행
- 논리적으로 다양한 컨트롤러가 존재한다 (복제 컨트롤러, 노드 컨트롤러, 엔드포인트 컨트롤러 …)
- 클러스터 상태를 지속적으로 점검하며 원하는 상태를 유지

3. **Scheduler**
- 배정되지 않은 새로 생성된 파드 감지하고 실행할 노드를 선택

4. **etcd**
- 모든 클러스터 데이터를 담는 쿠버네티스 뒷단의 저장소
- 고가용성 : 분산 시스템으로 구성해 안전성을 높임
- 일관성 : 가볍고 빠르면서 정확하게 설계
- Key-Value 형태로 데이터 저장

### 워커 노드(Worker Node)

- **노드 (Node)  ≈  컴퓨터**
- 쿠버네티스에서 **워커 머신**을 말함
- 컨테이너를 실행하는 **물리 서버** 또는 **가상 머신**
- 노드는 그냥 컨테이너가 돌아가는 **컴퓨터**인 셈! (EC2 인스턴스)

![image](https://github.com/user-attachments/assets/e307a8ca-4600-4b0f-a32c-aa709f90c600)

1. **kubelet**
- 각 노드에서 실행
- Pod를 실행/중지하고 상태를 체크

2. **kube-proxy**
- 클러스터의 각 [노드](https://kubernetes.io/ko/docs/concepts/architecture/nodes/)에서 실행되는 네트워크 프록시
- 노드의 네트워크 규칙을 유지 관리
- 서비스의 클러스터 IP와 포트를 외부 클라이언트가 접근할 수 있도록 함

3. **Pod**
- 쿠버네티스에서 생성, 관리, 배포되는 최소 단위

### Pod

> **쿠버네티스에서 생성되고, 스케줄링되며, 관리되고, 배포되는 최소 단위**

- 하나 이상의 컨테이너로 구성될 수 있지만 일반적으로 한 어플리케이션 컨테이너를 포함
- 파드는 언제나 **노드** 상에서 동작
- 동일한 파드 내의 컨테이너들은 `network namespace`를 공유하며 `localhost`로 통신
- 파드 내 컨테이너들은 함께 생성, 배치, 종료됨. 하나의 컨테이너가 망가지면 전체 파드가 종료되고 다시 스케줄링됨.
- 각 파드는 고유한 내부 IP를 가지며 재생성될 때마다 새로운 IP를 받음
- 유사한 요구사항 또는 의존성을 가진 컨테이너들만 한 pod 에 넣는 것이 권장됨

## 참고

- [쿠버네티스 공식 문서](https://kubernetes.io/ko/docs/home/)
- https://www.youtube.com/watch?v=Ia8IfowgU7s&list=PLIUCBpK1dpsNf1m-2kiosmfn2nXfljQgb
- https://jibinary.tistory.com/82
