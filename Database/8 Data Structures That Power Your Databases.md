# 8 Data Structures That Power Your Databases

>데이터베이스의 데이터의 인덱싱 위치(메모리, 디스크), 데이터의 포맷과 쓰기와 읽기의 비중등에 따라 인덱스 형식을 결정해야하기 때문에 상황에 따라 알맞은 형식을 적용해야한다.

![alt text](https://github.com/ByteByteGoHq/system-design-101/blob/main/images/8-ds-db.jpg?raw=true)

- Skiplist: Redis에서 사용하는 일반적인 인메모리 인덱스 타입, 확률적 구조를 사용한다. 단독으로는 잘 사용되지 않고 다른 자료구조와 함께 사용된다.

    |   ||||||||||
    |---|-|-|-|-|-|-|-|-|-|
    |   | 레벨 3 | 10 |    |    |    | 50 |    |    |    |
    |   | 레벨 2 | 10 |    | 30 |    | 50 |    |    | 70 |
    |   | 레벨 1 | 10 | 20 | 30 | 40 | 50 | 60 | 70 | 80 |


- Hash index: 컬렉션이나 맵 데이터 구조에서 가장 일반적으로 구현하는 인덱스 타입
- SSTable: 메모리에 먼저 저장 후 버퍼가 가득차게되면 데이터를 정렬해 디스크에 저장한다. 디스크에 저장된 SSTable은 불변한다. 데이터는 항상 정렬된 상태로 저장되기 때문에 검색이 가능하다.
- LSM tree: Skiplist와 SSTable을 더한 방식으로 데이터 쓰기에서 강점을 보인다.
- B-tree: 디스크에서 사용하며, 읽기/쓰기에서 일정한 성능을 보인다.
- Inverted index: Lucene에서 사용되며 문서를 인덱싱할 때 주로 사용된다. 직접 인덱스할 때와 다르게 문서가 포함하는 단어의 리스트를 저장하는 것이 아닌 단어가 어떤 문서에 나타나는지를 저장한다.
- Suffix tree: 문자열의 패턴을 검색할 수 있다. 모든 접미사를 저장해 문자열의 패턴을 찾을 때 빠른 검색이 가능하다. 즉, 문자열 자체를 찾는 상황에서는 필요하지 않다. 반복되는 패턴을 기반으로 압축을 하거나, DNA 서열 분석을 하는 등의 서비스에서 사용된다.
- R-tree: 데이터를 직사각형의 영역으로 그룹화하여 저장한다. 각 노드는 최소 경계 사각형 (MBR, Minimum Bounding Rectangle)으로 표현되며, MBR은 해당 노드의 모든 데이터를 포함한다. 가장 가까운 이웃을 찾는 등의 다차원 검색이 가능하다. 지도, 게임개발, 이미지 처리 등의 분야에서 사용한다.