![image](https://github.com/user-attachments/assets/46dce857-2278-4ade-babe-a8ce8909cdf9)

## SQL 실행 순서

| **순서** | **절 (Clause)** | **내용** |
| --- | --- | --- |
| 1 | FROM | `t1` 테이블을 불러옴 |
| 2 | JOIN | `t2` 테이블을 `t1`과 결합 |
| 3 | ON | 두 테이블을 연결하는 조건 (`t1.column_a = t2.column_a`)을 설정 |
| 4 | WHERE | 데이터의 필터링 조건을 적용 (`constraint_expression`) |
| 5 | GROUP BY | 특정 컬럼을 기준으로 데이터를 그룹화 |
| 6 | HAVING | 그룹화된 데이터에 대해 조건을 추가로 필터링 |
| 7 | ORDER BY | 데이터를 정렬 (`ASC`는 오름차순, `DESC`는 내림차순) |
| 8 | LIMIT | 결과 데이터에서 반환할 행의 개수를 제한 |

## DBMS의 SQL 실행 과정

1. **SQL 구문 분석 (Parsing)**
- 데이터베이스는 작성한 SQL 문장을 읽고 문법이 올바른지 확인
- 만약 문법 오류가 있다면 이 단계에서 실행이 중단됨

2. **내부 표현으로 변환 (Transformation)**
- SQL 문장을 내부적으로 처리하기 쉬운 형태(관계 대수, 트리 구조 등)로 변환
- 이 과정으로 DB 시스템이 SQL 문장의 의도를 더 효율적으로 이해하도록 도움

3. **최적화 (Optimization)**
- DBMS 옵티마이저가 최적의 실행 계획을 세움
    - 인덱스 사용 여부
    - 테이블 조인 순서
    - 필터링 조건을 어떤 순서로 처리할지 등등
- 실행 계획이 효율적일수록 쿼리 성능이 좋아짐

4. **실행 및 결과 반환 (Execution)**
- 최적화된 실행 계획에 따라 데이터를 처리
- 필요한 데이터를 검색하고 필터링 및 정렬을 적용한 뒤 결과 반환

## SQL 실행 시 고려 사항

1. **인덱스 및 캐시 사용**
- 데이터를 빠르게 찾기 위해 인덱스를 활용
- 이전에 사용했던 데이터를 메모리에 저장해 다시 사용하는 캐시 적용

2. **테이블 조인 순서**
- 여러 테이블을 결합할 때 어느 테이블을 먼저 처리할지에 따라 성능이 달라질 수 있음
- DB는 가장 효율적인 순서를 찾으려고 노력함

3. **동시성 제어**
- 여러 사용자가 동시에 데이터를 수정하거나 읽으려 할 때 충돌을 방지

4. **트랜잭션 관리**
- 하나의 작업이 여러 단계로 이루어질 경우, 모든 작업이 성공하거나 모두 취소되도록 보장

## 참고
https://github.com/ByteByteGoHq/system-design-101/?tab=readme-ov-file#visualizing-a-sql-query
